<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VK Ads Message Builder (Groups→Campaigns + Campaign Names)</title>
  <style>
    :root{
      --bg:#0b0f17;
      --card:#111827;
      --muted:#9ca3af;
      --text:#e5e7eb;
      --line:#243044;
      --btn:#2563eb;
      --btn2:#334155;
      --bad:#ef4444;
      --ok:#22c55e;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background:linear-gradient(180deg,#070a10 0%, #0b0f17 100%);
      color:var(--text);
      font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Helvetica Neue", sans-serif;
    }
    .wrap{max-width:1200px;margin:0 auto;padding:20px}
    h1{font-size:18px;margin:0 0 14px}
    .grid{
      display:grid;
      grid-template-columns: 1.05fr 0.95fr;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
    }
    .card{
      background:rgba(17,24,39,.85);
      border:1px solid rgba(36,48,68,.8);
      border-radius:14px;
      padding:14px;
      box-shadow:0 10px 30px rgba(0,0,0,.25);
      backdrop-filter: blur(6px);
    }
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    label{color:var(--muted);font-size:12px}
    input[type="text"], textarea, select{
      width:100%;
      background:#0b1220;
      color:var(--text);
      border:1px solid rgba(36,48,68,.9);
      border-radius:10px;
      padding:10px 10px;
      outline:none;
    }
    textarea{min-height:640px;resize:vertical;white-space:pre-wrap}
    .small{font-size:12px;color:var(--muted)}
    .btn{
      background:var(--btn);
      color:white;
      border:none;
      border-radius:10px;
      padding:10px 12px;
      cursor:pointer;
      font-weight:600;
    }
    .btn.secondary{background:var(--btn2)}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .pill{
      display:inline-flex;align-items:center;gap:6px;
      padding:6px 10px;border-radius:999px;
      border:1px solid rgba(36,48,68,.9);
      background:#0b1220;color:var(--muted);
      font-size:12px;
    }
    .ok{color:var(--ok)}
    .bad{color:var(--bad)}
    .hr{height:1px;background:rgba(36,48,68,.9);margin:10px 0}
    table{width:100%;border-collapse:collapse}
    th,td{
      border-bottom:1px solid rgba(36,48,68,.7);
      padding:8px 6px;
      vertical-align:top;
    }
    th{color:var(--muted);font-size:12px;text-align:left}
    td input[type="text"]{padding:8px;border-radius:9px}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    .nowrap{white-space:nowrap}
    .stickyTop{
      position:sticky; top:12px;
    }
    .checkCell{
      width:44px;
      text-align:center;
    }
    input[type="checkbox"]{
      width:18px;
      height:18px;
      accent-color: var(--btn);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>VK Ads → Сообщение по шаблону (агрегация групп → кампании + названия кампаний из отчёта)</h1>

    <div class="grid">
      <!-- LEFT: inputs + status + campaigns/comments + buttons -->
      <div class="card">
        <div class="row" style="justify-content:space-between">
          <div class="row" style="flex:1">
            <div style="min-width:260px;flex:1">
              <label>1) Отчёт по группам (.xlsx)</label>
              <input id="fileGroups" type="file" accept=".xlsx,.xls" />
              <div class="small" style="margin-top:6px">
                Берём метрики и агрегируем по <b>ID кампании</b>.
              </div>
            </div>
            <div style="min-width:260px;flex:1">
              <label>2) Отчёт по кампаниям (.xlsx)</label>
              <input id="fileCampaigns" type="file" accept=".xlsx,.xls" />
              <div class="small" style="margin-top:6px">
                Берём <b>только</b> названия кампаний и мэчим по <b>ID кампании</b>.
              </div>
            </div>
          </div>
          <div class="row">
            <span id="statusPill" class="pill">Файлы не загружены</span>
          </div>
        </div>

        <div class="hr"></div>

        <div class="row">
          <div style="flex:1;min-width:260px">
            <label>Заголовок сообщения (строка с ✅)</label>
            <input id="title" type="text" placeholder="Например: SAYAN - Гордая" />
            <div class="small" style="margin-top:6px">
              Если пусто — будет попытка собрать автоматически.
            </div>
          </div>
          <div style="flex:1;min-width:260px">
            <label>Строка итогов (➡ ... - все кампании)</label>
            <input id="totalLabel" type="text" placeholder="Например: SAYAN - Гордая (скрытые) - все кампании" />
            <div class="small" style="margin-top:6px">
              Если пусто — будет попытка собрать «Артист - Трек (… ) - все кампании».
            </div>

            <div style="margin-top:10px">
              <label>Статус итогового сообщения</label>
              <select id="totalStatus">
                <option value="">(оставить пустым)</option>
                <option value="Модерация">Модерация</option>
                <option value="Обучение">Обучение</option>
                <option value="Идут показы">Идут показы</option>
                <option value="Остановлена">Остановлена</option>
                <option value="Финал">Финал</option>
              </select>
              <div class="small" style="margin-top:6px">
                Применяется только к последнему суммарному блоку.
              </div>
            </div>
          </div>
        </div>

        <div class="hr"></div>

        <div class="row" style="justify-content:space-between">
          <div>
            <div style="font-weight:700">Кампании и комментарии</div>
            <div class="small">
              Галочка определяет, попадёт ли кампания в текст сообщения. На суммы итога это не влияет.
            </div>
          </div>
          <div class="row">
            <span class="pill">Статус кампании: <span class="ok">active</span> если есть активные группы, иначе <span class="bad">blocked</span></span>
          </div>
        </div>

        <div class="hr"></div>

        <div id="tableWrap" class="small">Пока нет данных.</div>

        <div class="hr"></div>

        <div class="row">
          <button id="btnGenerate" class="btn" disabled>Сформировать сообщение</button>
          <span class="small" id="hint"></span>
        </div>
      </div>

      <!-- RIGHT: message output + copy button -->
      <div class="card stickyTop">
        <label>Сообщение</label>
        <textarea id="output" class="mono" placeholder="Здесь появится сообщение…"></textarea>
        <div class="hr"></div>
        <div class="row">
          <button id="btnCopy" class="btn secondary" disabled>Скопировать</button>
          <span class="small" id="copyHint"></span>
        </div>
      </div>
    </div>
  </div>

  <!-- SheetJS (xlsx) -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script>
    const els = {
      fileGroups: document.getElementById('fileGroups'),
      fileCampaigns: document.getElementById('fileCampaigns'),
      statusPill: document.getElementById('statusPill'),
      btnGenerate: document.getElementById('btnGenerate'),
      btnCopy: document.getElementById('btnCopy'),
      output: document.getElementById('output'),
      tableWrap: document.getElementById('tableWrap'),
      title: document.getElementById('title'),
      totalLabel: document.getElementById('totalLabel'),
      totalStatus: document.getElementById('totalStatus'),
      hint: document.getElementById('hint'),
      copyHint: document.getElementById('copyHint'),
    };

    // --- State ---
    let groupRows = [];                       // rows from groups report
    let campaignsAgg = [];                    // aggregated campaigns
    const campaignNamesFromReport = new Map();// id -> name (from campaigns report)
    const campaignNamesManual = new Map();    // id -> name (manual override)
    const campaignComments = new Map();       // id -> comment
    const campaignIncluded = new Map();       // id -> boolean include
    let totalsIncluded = true;                // include totals block
    let totalComment = '';

    let groupsLoaded = false;
    let campaignsReportLoaded = false;

    const nfInt = new Intl.NumberFormat('ru-RU');
    const nfMoney = new Intl.NumberFormat('ru-RU', { minimumFractionDigits: 2, maximumFractionDigits: 2 });

    function normKey(k){ return String(k ?? '').replace(/\s+/g,' ').trim(); }
    function escapeHtml(s){
      return String(s ?? '')
        .replaceAll('&','&amp;')
        .replaceAll('<','&lt;')
        .replaceAll('>','&gt;')
        .replaceAll('"','&quot;')
        .replaceAll("'","&#039;");
    }
    function escapeHtmlAttr(s){ return escapeHtml(s).replaceAll('\n',' '); }

    function getVal(row, keyCandidates){
      for (const k of keyCandidates){
        const nk = normKey(k);
        if (Object.prototype.hasOwnProperty.call(row, nk)) return row[nk];
      }
      return undefined;
    }

    function asNumber(x){
      if (x === null || x === undefined) return 0;
      if (typeof x === 'number') return isFinite(x) ? x : 0;
      const s = String(x).replace(/\s/g,'').replace(',', '.');
      const n = Number(s);
      return isFinite(n) ? n : 0;
    }
    function asInt(x){ return Math.round(asNumber(x)); }
    function fmtInt(x){ return nfInt.format(asInt(x)); }
    function fmtMoney(x){ return nfMoney.format(asNumber(x)).replace(/\u00A0/g,' '); }

    function statusText(raw){
      const s = String(raw ?? '').toLowerCase().trim();
      if (s === 'active') return 'Идут показы';
      if (s === 'blocked') return 'Остановлена';
      if (!s) return '';
      return s;
    }

    function groupStatusToCampaign(statuses){
      const norm = statuses.map(s => String(s ?? '').toLowerCase().trim()).filter(Boolean);
      if (norm.includes('active')) return 'active';
      if (norm.length && norm.every(s => s === 'blocked')) return 'blocked';
      return norm[0] || '';
    }

    function guessArtistTrackFullFromName(groupName){
      const parts = String(groupName ?? '').split(' - ').map(p => p.trim()).filter(Boolean);
      if (parts.length >= 2){
        const artist = parts[parts.length - 2];
        const track = parts[parts.length - 1];
        return `${artist} - ${track}`;
      }
      return String(groupName ?? '').trim();
    }
    function removeTrailingParen(trackPart){
      return String(trackPart ?? '').replace(/\s*\([^)]*\)\s*$/,'').trim();
    }
    function detectSegmentTypeFromGroupName(groupName){
      const s = String(groupName ?? '').toLowerCase();
      const out = new Set();
      if (s.includes('слушател')) out.add('слушатели');
      if (s.includes('баз')) out.add('базы');
      return Array.from(out);
    }
    function buildCampaignAutoName(groupNames){
      const first = groupNames.find(Boolean) || '';
      const artistTrackFull = guessArtistTrackFullFromName(first);

      const segSet = new Set();
      for (const gn of groupNames){
        for (const seg of detectSegmentTypeFromGroupName(gn)) segSet.add(seg);
      }
      const segs = Array.from(segSet);
      const order = ['слушатели','базы'];
      segs.sort((a,b)=>{
        const ia = order.indexOf(a); const ib = order.indexOf(b);
        if (ia === -1 && ib === -1) return a.localeCompare(b,'ru');
        if (ia === -1) return 1;
        if (ib === -1) return -1;
        return ia - ib;
      });

      if (segs.length) return `${artistTrackFull} - ${segs.join(' + ')}`;
      return artistTrackFull;
    }

    function resolveCampaignName(id, autoName){
      const manual = (campaignNamesManual.get(id) || '').trim();
      if (manual) return manual;
      const fromReport = (campaignNamesFromReport.get(id) || '').trim();
      if (fromReport) return fromReport;
      return (autoName || '').trim();
    }

    function ensureIncludeState(){
      for (const c of campaignsAgg){
        if (!campaignIncluded.has(c.id)) campaignIncluded.set(c.id, true);
      }
    }

    function setPill(){
      const parts = [];
      if (groupsLoaded) parts.push('Группы: загружено');
      else parts.push('Группы: нет');

      if (campaignsReportLoaded) parts.push('Кампании: имена загружены');
      else parts.push('Кампании: имена не загружены');

      const ok = groupsLoaded;
      els.statusPill.textContent = parts.join(' · ');
      els.statusPill.classList.toggle('ok', ok);
      els.statusPill.classList.toggle('bad', !ok);
    }

    function aggregateToCampaigns(){
      const KEY_CAMPAIGN_ID = ['ID кампании','ID Кампании','Campaign ID','campaign_id','ID campaign','CampaignId','ID Campaign'];
      const KEY_GROUP_NAME  = ['Название группы'];
      const KEY_STATUS      = ['Статус'];
      const KEY_SPEND       = ['Потрачено всего, ₽', 'Потрачено всего, ₽ ', 'Потрачено, ₽'];
      const KEY_IMP         = ['Показы'];
      const KEY_LISTEN      = ['Начали прослушивание'];
      const KEY_ADDS        = ['Добавили аудио'];

      const map = new Map();
      for (const r of groupRows){
        const cidRaw = getVal(r, KEY_CAMPAIGN_ID);
        const cid = String(cidRaw ?? '').trim();
        if (!cid) continue;

        const gn = String(getVal(r, KEY_GROUP_NAME) ?? '').trim();
        const st = String(getVal(r, KEY_STATUS) ?? '').trim();
        const spend = asNumber(getVal(r, KEY_SPEND));
        const imp = asInt(getVal(r, KEY_IMP));
        const listen = asInt(getVal(r, KEY_LISTEN));
        const adds = asInt(getVal(r, KEY_ADDS));

        if (!map.has(cid)){
          map.set(cid, { id: cid, groupNames: [], statuses: [], spend: 0, imp: 0, listen: 0, adds: 0 });
        }
        const a = map.get(cid);
        a.groupNames.push(gn);
        a.statuses.push(st);
        a.spend += spend;
        a.imp += imp;
        a.listen += listen;
        a.adds += adds;
      }

      const list = [];
      for (const a of map.values()){
        const autoName = buildCampaignAutoName(a.groupNames);
        list.push({
          id: a.id,
          autoName,
          statusRaw: groupStatusToCampaign(a.statuses),
          spend: a.spend,
          imp: a.imp,
          listen: a.listen,
          adds: a.adds,
          groupsCount: a.groupNames.length,
        });
      }

      list.sort((x,y)=>{
        const nx = resolveCampaignName(x.id, x.autoName);
        const ny = resolveCampaignName(y.id, y.autoName);
        return nx.localeCompare(ny, 'ru', { sensitivity:'base' });
      });

      campaignsAgg = list;
      ensureIncludeState();
    }

    function guessTitleAndTotalsLabel(){
      if (!campaignsAgg.length) return;

      const first = campaignsAgg[0];
      const nameForTitle = resolveCampaignName(first.id, first.autoName);
      const full = guessArtistTrackFullFromName(nameForTitle);
      const parts = full.split(' - ').map(s=>s.trim());
      let title = full;
      if (parts.length >= 2){
        const artist = parts[0];
        const track = removeTrailingParen(parts.slice(1).join(' - '));
        title = `${artist} - ${track}`;
      }
      if (!els.title.value.trim()) els.title.value = title;

      if (!els.totalLabel.value.trim()){
        els.totalLabel.value = `${guessArtistTrackFullFromName(nameForTitle)} - все кампании`;
      }
    }

    function buildMessage(){
      const title = (els.title.value || '').trim();
      const totalsLabel = (els.totalLabel.value || '').trim();
      let out = '';
      if (title) out += `✅ ${title}\n\n`;

      // IMPORTANT: totals sums are calculated over ALL campaigns (not filtered)
      let sumSpend = 0, sumImp = 0, sumListen = 0, sumAdds = 0;

      // First: compute totals using all campaigns
      for (const c of campaignsAgg){
        sumSpend += asNumber(c.spend);
        sumImp += asInt(c.imp);
        sumListen += asInt(c.listen);
        sumAdds += asInt(c.adds);
      }

      // Second: output only included campaigns
      for (const c of campaignsAgg){
        const include = campaignIncluded.get(c.id) !== false; // default true
        if (!include) continue;

        const name = resolveCampaignName(c.id, c.autoName);
        const comment = campaignComments.get(c.id) || '';

        const spend = asNumber(c.spend);
        const imp = asInt(c.imp);
        const listen = asInt(c.listen);
        const adds = asInt(c.adds);

        out += `➡ ${name}\n\n`;
        out += `Потрачено: ${fmtMoney(spend)} ₽\n`;
        out += `Показы: ${fmtInt(imp)}\n`;
        out += `Начали прослушивание: ${fmtInt(listen)}\n`;
        out += `Добавлено: ${fmtInt(adds)}\n`;

        const cpa = (adds > 0) ? (spend / adds) : 0;
        out += `Ср. стоимость добавления: ${adds>0 ? (fmtMoney(cpa) + ' ₽') : '—'}\n\n`;

        out += `Статус: ${statusText(c.statusRaw)}\n`;
        out += `Комментарий: ${comment}\n\n`;
      }

      // Totals block visibility is controlled by checkbox, but sums are still global
      if (totalsLabel && totalsIncluded){
        const totalCpa = (sumAdds > 0) ? (sumSpend / sumAdds) : 0;
        out += `➡ ${totalsLabel}\n\n`;
        out += `Потрачено: ${fmtMoney(sumSpend)} ₽\n`;
        out += `Показы: ${fmtInt(sumImp)}\n`;
        out += `Начали прослушивание: ${fmtInt(sumListen)}\n`;
        out += `Добавлено: ${fmtInt(sumAdds)}\n`;
        out += `Ср. стоимость добавления: ${sumAdds>0 ? (fmtMoney(totalCpa) + ' ₽') : '—'}\n\n`;

        const totalStatus = (els.totalStatus?.value || '').trim();
        out += `Статус: ${totalStatus}\nКомментарий: ${totalComment}\n`;
      }

      els.output.value = out.trim() + '\n';
      els.btnCopy.disabled = !els.output.value.trim();
    }

    function renderTable(){
      if (!campaignsAgg.length){
        els.tableWrap.innerHTML = 'Сначала загрузите отчёт по группам.';
        return;
      }

      let html = `<table>
        <thead><tr>
          <th class="checkCell">✓</th>
          <th style="width:44%">Кампания (можно переименовать)</th>
          <th style="width:14%">Статус</th>
          <th style="width:42%">Комментарий</th>
        </tr></thead><tbody>`;

      // Totals row with checkbox
      html += `<tr>
        <td class="checkCell">
          <input id="totalsInclude" type="checkbox" ${totalsIncluded ? 'checked' : ''} title="Показывать итоговый блок в сообщении">
        </td>
        <td><b>Итог (сумма по всем кампаниям)</b></td>
        <td></td>
        <td>
          <input id="totalCommentInput" type="text" placeholder="Комментарий к суммарному блоку" value="${escapeHtmlAttr(totalComment)}">
        </td>
      </tr>`;

      for (const c of campaignsAgg){
        const stRaw = String(c.statusRaw || '').trim();
        const curComment = campaignComments.get(c.id) || '';
        const nameAuto = (c.autoName || '').trim();
        const nameReport = (campaignNamesFromReport.get(c.id) || '').trim();
        const nameManual = (campaignNamesManual.get(c.id) || '').trim();
        const displayName = resolveCampaignName(c.id, c.autoName);
        const include = campaignIncluded.get(c.id) !== false;

        const src = nameManual ? 'ручн.' : (nameReport ? 'из отчёта кампаний' : 'авто');

        html += `<tr>
          <td class="checkCell">
            <input data-include="${escapeHtmlAttr(c.id)}" type="checkbox" ${include ? 'checked' : ''} title="Включать кампанию в сообщение">
          </td>
          <td>
            <div class="small">ID: <span class="mono">${escapeHtml(c.id)}</span> · групп: ${escapeHtml(String(c.groupsCount))} · источник: ${escapeHtml(src)}</div>
            <input data-cname="${escapeHtmlAttr(c.id)}" type="text" value="${escapeHtmlAttr(displayName)}" placeholder="Название кампании">
            <div class="small">Авто: ${escapeHtml(nameAuto)}${nameReport ? `<br>Из отчёта кампаний: ${escapeHtml(nameReport)}` : ''}</div>
          </td>
          <td>
            <span class="nowrap">${escapeHtml(statusText(stRaw))}</span>
            <div class="small mono">${escapeHtml(stRaw)}</div>
          </td>
          <td>
            <input data-ccomment="${escapeHtmlAttr(c.id)}" type="text" placeholder="Оставить пустым" value="${escapeHtmlAttr(curComment)}">
          </td>
        </tr>`;
      }

      html += `</tbody></table>`;
      els.tableWrap.innerHTML = html;

      // totals
      const totalsCb = document.getElementById('totalsInclude');
      if (totalsCb){
        totalsCb.addEventListener('change', (e)=>{
          totalsIncluded = !!e.target.checked;
          buildMessage();
        });
      }
      const totalInp = document.getElementById('totalCommentInput');
      if (totalInp){
        totalInp.addEventListener('input', (e)=>{
          totalComment = e.target.value;
          buildMessage();
        });
      }

      // include checkboxes
      els.tableWrap.querySelectorAll('input[data-include]').forEach(inp => {
        inp.addEventListener('change', (e)=>{
          const id = e.target.getAttribute('data-include');
          campaignIncluded.set(id, !!e.target.checked);
          buildMessage();
        });
      });

      // rename
      els.tableWrap.querySelectorAll('input[data-cname]').forEach(inp => {
        inp.addEventListener('input', (e)=>{
          const id = e.target.getAttribute('data-cname');
          campaignNamesManual.set(id, e.target.value);
          // keep sorting consistent with new name
          aggregateToCampaigns();
          renderTable();
          buildMessage();
        });
      });

      // comment
      els.tableWrap.querySelectorAll('input[data-ccomment]').forEach(inp => {
        inp.addEventListener('input', (e)=>{
          const id = e.target.getAttribute('data-ccomment');
          campaignComments.set(id, e.target.value);
          buildMessage();
        });
      });
    }

    async function parseXlsx(file){
      const buf = await file.arrayBuffer();
      const wb = XLSX.read(buf, { type:'array' });
      return wb;
    }

    function sheetToRowsNormalized(wb, preferredSheetName){
      const sheetName = (preferredSheetName && wb.SheetNames.includes(preferredSheetName))
        ? preferredSheetName
        : wb.SheetNames[0];
      const ws = wb.Sheets[sheetName];
      const raw = XLSX.utils.sheet_to_json(ws, { defval: '' });
      return raw.map(obj => {
        const out = {};
        for (const [k,v] of Object.entries(obj)){
          out[normKey(k)] = v;
        }
        return out;
      });
    }

    async function handleGroupsFile(file){
      const wb = await parseXlsx(file);
      groupRows = sheetToRowsNormalized(wb, 'Группы');
      groupsLoaded = groupRows.length > 0;

      if (!groupsLoaded){
        campaignsAgg = [];
        return { missing: ['(пустой файл)'] };
      }

      const must = ['ID кампании','Название группы','Статус','Потрачено всего, ₽','Показы','Начали прослушивание','Добавили аудио'];
      const cols = new Set(Object.keys(groupRows[0] || {}));
      const missing = must.filter(m => !cols.has(m));

      aggregateToCampaigns();
      guessTitleAndTotalsLabel();
      return { missing };
    }

    async function handleCampaignsFile(file){
      const wb = await parseXlsx(file);
      const rows = sheetToRowsNormalized(wb, 'Кампании');

      campaignNamesFromReport.clear();
      const KEY_ID = ['ID кампании','ID Кампании','Campaign ID','campaign_id','ID campaign'];
      const KEY_NAME = ['Название кампании','Campaign name','campaign_name','Name'];

      for (const r of rows){
        const id = String(getVal(r, KEY_ID) ?? '').trim();
        const name = String(getVal(r, KEY_NAME) ?? '').trim();
        if (id && name){
          campaignNamesFromReport.set(id, name);
        }
      }

      campaignsReportLoaded = campaignNamesFromReport.size > 0;

      if (groupsLoaded){
        aggregateToCampaigns();
        renderTable();
        buildMessage();
      }

      return { count: campaignNamesFromReport.size };
    }

    function resetForNewGroups(){
      campaignsAgg = [];
      groupRows = [];
      campaignComments.clear();
      campaignNamesManual.clear();
      campaignIncluded.clear();
      totalsIncluded = true;
      totalComment = '';
      if (els.totalStatus) els.totalStatus.value = '';
      els.output.value = '';
      els.btnGenerate.disabled = true;
      els.btnCopy.disabled = true;
      els.hint.textContent = '';
      els.copyHint.textContent = '';
    }

    els.fileGroups.addEventListener('change', async (e)=>{
      const f = e.target.files?.[0];
      resetForNewGroups();

      if (!f){
        groupsLoaded = false;
        setPill();
        renderTable();
        return;
      }

      try{
        const res = await handleGroupsFile(f);
        setPill();

        if (!groupsLoaded){
          els.hint.textContent = 'Файл групп пустой или не распознан.';
          renderTable();
          return;
        }

        if (res.missing.length){
          els.hint.textContent = `Не найдены колонки: ${res.missing.join(', ')}. Я всё равно попробую агрегировать по ID кампании.`;
        } else {
          els.hint.textContent = '';
        }

        renderTable();
        els.btnGenerate.disabled = false;

      }catch(err){
        console.error(err);
        groupsLoaded = false;
        setPill();
        els.hint.textContent = String(err?.message || err);
        renderTable();
      }
    });

    els.fileCampaigns.addEventListener('change', async (e)=>{
      const f = e.target.files?.[0];
      if (!f){
        campaignNamesFromReport.clear();
        campaignsReportLoaded = false;
        setPill();
        if (groupsLoaded){
          aggregateToCampaigns();
          renderTable();
          buildMessage();
        }
        return;
      }

      try{
        const res = await handleCampaignsFile(f);
        setPill();
        els.hint.textContent = groupsLoaded
          ? `Загружены имена кампаний: ${res.count}.`
          : `Загружены имена кампаний: ${res.count}. Теперь загрузите отчёт по группам.`;
      }catch(err){
        console.error(err);
        campaignsReportLoaded = false;
        setPill();
        els.hint.textContent = String(err?.message || err);
      }
    });

    els.btnGenerate.addEventListener('click', ()=>{
      if (!groupsLoaded || !campaignsAgg.length) return;
      buildMessage();
      els.hint.textContent = 'Готово. Скопируй справа.';
    });

    els.btnCopy.addEventListener('click', async ()=>{
      const text = els.output.value || '';
      if (!text.trim()) return;
      try{
        await navigator.clipboard.writeText(text);
        els.copyHint.textContent = 'Скопировано в буфер обмена.';
      }catch(e){
        els.output.focus();
        els.output.select();
        document.execCommand('copy');
        els.copyHint.textContent = 'Скопировано (через выделение).';
      }
    });

    els.title.addEventListener('input', ()=>{ if (groupsLoaded) buildMessage(); });
    els.totalLabel.addEventListener('input', ()=>{ if (groupsLoaded) buildMessage(); });
    els.totalStatus.addEventListener('change', ()=>{ if (groupsLoaded) buildMessage(); });

    setPill();
  </script>
</body>
</html>
